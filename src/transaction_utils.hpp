#ifndef GDK_TRANSACTION_UTILS_HPP
#define GDK_TRANSACTION_UTILS_HPP
#pragma once

#include <array>
#include <memory>
#include <optional>
#include <set>
#include <utility>

#include "amount.hpp"

namespace ga {
namespace sdk {
    class ga_pubkeys;
    class session_impl;
    class user_pubkeys;
    class Tx;

    enum class script_type : int {
        // Script types returned by the Green backend server
        ga_pubkey_hash_out = 2, // Not actually generated by the server, used for sweeping
        ga_p2sh_fortified_out = 10,
        ga_p2sh_p2wsh_fortified_out = 14,
        ga_p2sh_p2wsh_csv_fortified_out = 15,
        ga_redeem_p2sh_fortified = 150,
        ga_redeem_p2sh_p2wsh_fortified = 159,
        ga_redeem_p2sh_p2wsh_csv_fortified = 162
    };

    namespace address_type {
        extern const std::string p2pkh; // Not generated by the server, used for sweeping
        extern const std::string p2wpkh;
        extern const std::string p2sh_p2wpkh;
        extern const std::string p2sh;
        extern const std::string p2wsh; // Actually p2sh-p2wsh
        extern const std::string csv;
    } // namespace address_type

    bool is_segwit_address_type(const nlohmann::json& utxo);

    std::string get_address_from_scriptpubkey(const network_parameters& net_params, byte_span_t scriptpubkey);

    std::string get_address_from_utxo(session_impl& session, const nlohmann::json& utxo, bool verify_script = true);

    std::vector<unsigned char> multisig_output_script_from_utxo(const network_parameters& net_params,
        ga_pubkeys& pubkeys, user_pubkeys& usr_pubkeys, user_pubkeys& recovery_pubkeys, const nlohmann::json& utxo);

    // Make a multisig scriptSig
    std::vector<unsigned char> input_script(bool low_r, const std::vector<unsigned char>& prevout_script,
        const ecdsa_sig_t& user_sig, const ecdsa_sig_t& ga_sig, uint32_t user_sighash_flags, uint32_t ga_sighash_flags);

    // Make a multisig scriptSig with a user signature and PUSH(0) marker for the GA sig
    std::vector<unsigned char> input_script(bool low_r, const std::vector<unsigned char>& prevout_script,
        const ecdsa_sig_t& user_sig, uint32_t user_sighash_flags);

    // Make a multisig scriptSig with dummy signatures for (fee estimation)
    std::vector<unsigned char> dummy_input_script(bool low_r, const std::vector<unsigned char>& prevout_script);

    std::vector<unsigned char> dummy_scriptsig_p2pkh(bool low_r, byte_span_t pub_key);

    std::vector<unsigned char> witness_script(byte_span_t script, uint32_t witness_ver);

    // Get scriptpubkey from address (address is expected to be valid)
    std::vector<unsigned char> scriptpubkey_from_address(
        const network_parameters& net_params, const std::string& address, bool allow_unconfidential);

    // Returns true if the UXTO is not a sweep UTXO and has a wallet address_type
    bool is_wallet_utxo(const nlohmann::json& utxo);

    // Set the error in a transaction, if it hasn't been set already
    void set_tx_error(nlohmann::json& result, const std::string& error, bool overwrite = false);

    std::string validate_tx_addressee(
        session_impl& session, const network_parameters& net_params, nlohmann::json& addressee);

    // Add an output from a JSON addressee
    void add_tx_addressee_output(session_impl& session, nlohmann::json& result, Tx& tx, nlohmann::json& addressee);

    // Add an output from a JSON change output, returns the index in tx->outputs
    // Note the output is zero valued and is expected to be updated later
    size_t add_tx_change_output(session_impl& session, nlohmann::json& result, Tx& tx, const std::string& asset_id);

    // Add a fee output to a tx, returns the index in tx->outputs
    size_t add_tx_fee_output(session_impl& session, nlohmann::json& result, Tx& tx, amount::value_type satoshi);

    // Update the json tx size/fee rate information from tx
    void update_tx_size_info(const network_parameters& net_params, const Tx& tx, nlohmann::json& result);

    // Get the output index of an assets change
    std::optional<int> get_tx_change_index(nlohmann::json& result, const std::string& asset_id);

    // Return whether all addressees and change outputs are unique (different addresses),
    // and if spk is given, return whether it would be unique if added
    bool are_tx_outputs_unique(const nlohmann::json& result, const std::string& spk = std::string());

    // Update the json tx representation with info from tx
    void update_tx_info(session_impl& session, const Tx& tx, nlohmann::json& result);

    // Compute the subaccounts a tx uses from its inputs
    std::set<uint32_t> get_tx_subaccounts(const nlohmann::json& details);

    // Return the single subaccount in subaccounts or throw an error
    uint32_t get_single_subaccount(const std::set<uint32_t>& subaccounts);

    // Returns true if a tx has AMP inputs
    bool tx_has_amp_inputs(session_impl& session, const nlohmann::json& details);

    // Returns address_type from script_type
    std::string get_utxo_address_type_from_script_type(const nlohmann::json& utxo);
} // namespace sdk
} // namespace ga

#endif
